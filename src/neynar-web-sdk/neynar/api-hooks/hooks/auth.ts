/**
 * Neynar Auth & Registration API hooks
 *
 * Hooks for authentication, account registration, and developer-managed auth.
 */

import {
  useApiQuery,
  useApiMutation,
  useApiQueryClient,
  STALE_TIME,
  type ExtendedMutationOptions,
  type QueryHookOptions,
  type QueryHookResult,
  type MutationHookResult,
} from "../../../private/api-hooks";
import { neynarQueryKeys } from "../query-keys";
import { buildNeynarQuery } from "../helpers";
import type {
  AuthorizationUrlResponse,
  DeveloperManagedSigner,
  RegisterUserResponse,
  RegisterUserOnChainResponse,
  RegisterSignedKeyForDeveloperManagedAuthAddress200Response,
  UpdateUserReqBodyVerifiedAccounts,
  UpdateUserReqBodyLocation,
  RegisterUserOnChainReqBodyPreRegistrationCallsInner,
  RegisterUserOnChainReqBodyRegistration,
  RegisterUserOnChainReqBodySignersInner,
  SignedKeyRequestSponsor,
} from "../sdk-response-types";

/**
 * Parameters for fetching authorization URL
 */
export type UseAuthorizationUrlParams = {
  /**
   * Your application's client ID
   *
   * This identifies your application to the Neynar API
   */
  client_id: string;

  /**
   * OAuth response type
   *
   * Must be "code" for authorization code flow
   */
  response_type: "code";
};

/**
 * Parameters for registering a new Farcaster account
 */
export type UseRegisterAccountParams = {
  /**
   * Signature from custody address proving ownership
   *
   * This signature proves control of the custody address and authorizes registration
   */
  signature: string;

  /**
   * FID (Farcaster ID) to register
   *
   * The unique identifier for the new Farcaster account
   */
  fid: number;

  /**
   * Ethereum custody address requesting registration
   *
   * The custody address that will own this Farcaster account
   */
  requested_user_custody_address: string;

  /**
   * Unix timestamp for signature expiration
   *
   * Controls when the signature becomes invalid (in seconds)
   */
  deadline: number;

  /**
   * Optional desired Farcaster username
   *
   * If available, will be assigned to the account
   */
  fname?: string;

  /**
   * Optional metadata for user profile
   *
   * Includes bio, pfp_url, url, username, display_name, verified_accounts, and location
   */
  metadata?: {
    /** User bio text */
    bio?: string;
    /** Profile picture URL */
    pfp_url?: string;
    /** User website URL */
    url?: string;
    /** Username */
    username?: string;
    /** Display name */
    display_name?: string;
    /** Verified accounts */
    verified_accounts?: UpdateUserReqBodyVerifiedAccounts;
    /** User location */
    location?: UpdateUserReqBodyLocation;
  };
};

/**
 * Parameters for registering a new Farcaster account onchain
 */
export type UseRegisterAccountOnchainParams = {
  /**
   * Idempotency key for preventing duplicate requests
   *
   * **Format:** 16-character string recommended
   * **Usage:** Use the same key on retry attempts
   * **Requirements:**
   * - Must be a unique identifier for each distinct request
   * - Pre-registration calls must be idempotent when using this key
   */
  idem?: string;

  /**
   * Array of pre-registration blockchain calls to execute before account creation
   *
   * These calls are executed before the account is created on-chain
   */
  pre_registration_calls?: Array<RegisterUserOnChainReqBodyPreRegistrationCallsInner>;

  /**
   * Required registration data
   *
   * Includes signature, custody address, FID, and deadline
   */
  registration: RegisterUserOnChainReqBodyRegistration;

  /**
   * Number of storage units to allocate for the account
   *
   * Determines how much storage the account will have
   */
  storage_units?: number;

  /**
   * Array of signer configurations to register with the account
   *
   * Signers that will be authorized to act on behalf of this account
   */
  signers?: Array<RegisterUserOnChainReqBodySignersInner>;
};

/**
 * Parameters for registering a signed key for developer managed authentication
 */
export type UseRegisterDeveloperManagedSignedKeyParams = {
  /**
   * Ed25519 public key to register
   *
   * The public key that will be authorized to sign messages
   */
  public_key: string;

  /**
   * Signature generated by the custody address of the app
   *
   * Signed data includes: app_fid, deadline, and the signer's public key
   */
  signature: string;

  /**
   * The unique identifier of a farcaster user or app
   *
   * This is the FID of your application (unsigned integer)
   */
  app_fid: number;

  /**
   * Unix timestamp in seconds controlling signed key validity
   *
   * **Recommended:** 24 hours from now
   * **Example:** `Math.floor(Date.now() / 1000) + 86400`
   */
  deadline: number;

  /**
   * URL to redirect to after signer approval
   *
   * **Note:** Should only be used when requesting a signer from a native mobile application
   */
  redirect_url?: string;

  /**
   * Optional sponsor information for the signed key request
   *
   * Allows sponsoring the signer registration costs
   */
  sponsor?: SignedKeyRequestSponsor;
};

/**
 * Fetches authorized url useful for SIWN login operation
 *
 * **Special Behaviors:**
 * - Extracts and returns just the URL string from the response object for convenience
 * - URL is stable and can be cached
 *
 * @param params - Query parameters for authorization URL generation
 * @param options - TanStack Query options for caching and request behavior
 * @returns TanStack Query result with authorization URL
 *
 * @example Basic authorization flow
 * ```tsx
 * function LoginButton() {
 *   const { data: authUrl, isLoading } = useAuthorizationUrl({
 *     client_id: 'your-client-id',
 *     response_type: 'code'
 *   });
 *
 *   if (isLoading) return <div>Generating auth URL...</div>;
 *
 *   return (
 *     <a href={authUrl} target="_blank">
 *       Sign in with Farcaster
 *     </a>
 *   );
 * }
 * ```
 *
 * @see {@link useRegisterAccount} for registering a new account after authentication
 * @see {@link useDeveloperManagedAuth} for developer-managed authentication flow
 */
export function useAuthorizationUrl(
  params: UseAuthorizationUrlParams,
  options?: QueryHookOptions<AuthorizationUrlResponse, string>,
): QueryHookResult<string> {
  const queryParams = buildNeynarQuery(params);

  return useApiQuery<AuthorizationUrlResponse, string>(
    neynarQueryKeys.auth.authorizationUrl(params),
    `/api/neynar/auth/authorization-url?${queryParams}`,
    {
      staleTime: STALE_TIME.STABLE,
      ...options,
      select: (response: AuthorizationUrlResponse) => {
        // SDK returns: { authorization_url: string }
        // Extract the URL string for convenience
        return response?.authorization_url;
      },
    },
  );
}

/**
 * Retrieves information about a developer-managed signer address by Ethereum address
 *
 * @param address - The Ethereum address to lookup
 * @param options - TanStack Query options for caching and request behavior
 * @returns TanStack Query result with developer-managed signer data
 *
 * @example Basic usage
 * ```tsx
 * function SignerStatus({ address }: { address: string }) {
 *   const { data: signer, isLoading } = useDeveloperManagedAuth(address);
 *   if (isLoading) return <div>Loading...</div>;
 *   return <div>Status: {signer?.status}</div>;
 * }
 * ```
 *
 * @see {@link useRegisterDeveloperManagedSignedKey} for registering a new signed key
 * @see {@link useAuthorizationUrl} for standard OAuth authentication flow
 */
export function useDeveloperManagedAuth(
  address: string,
  options?: QueryHookOptions<DeveloperManagedSigner, DeveloperManagedSigner>,
): QueryHookResult<DeveloperManagedSigner> {
  return useApiQuery<DeveloperManagedSigner, DeveloperManagedSigner>(
    neynarQueryKeys.auth.developerManagedAddress(address),
    `/api/neynar/auth/developer-managed/${address}`,
    {
      enabled: Boolean(address?.trim()),
      staleTime: STALE_TIME.NORMAL,
      ...options,
      select: (response: DeveloperManagedSigner) => {
        // SDK returns: DeveloperManagedSigner object directly
        // Pass through entire response - contains public_key, status, fid, etc.
        return response;
      },
    },
  );
}

/**
 * Creates a new Farcaster account with the provided signature and details
 *
 * @param options - TanStack Query mutation options for callbacks and error handling
 * @returns TanStack Query mutation result
 *   - `mutate: (params:` {@link UseRegisterAccountParams}`) => void` - Trigger account registration
 *
 * @example
 * ```tsx
 * function RegisterAccount() {
 *   const { mutate } = useRegisterAccount({
 *     onSuccess: (data) => console.log('Registered:', data.user)
 *   });
 *   return <button onClick={() => mutate({ signature, fid, requested_user_custody_address, deadline })}>Register</button>;
 * }
 * ```
 *
 * @see {@link useRegisterAccountOnchain} for onchain registration with pre-registration calls
 * @see {@link useAuthorizationUrl} for getting authorization URL before registration
 */
export function useRegisterAccount(
  options?: ExtendedMutationOptions<
    RegisterUserResponse,
    UseRegisterAccountParams
  >,
): MutationHookResult<RegisterUserResponse, UseRegisterAccountParams> {
  const queryClient = useApiQueryClient();

  return useApiMutation<RegisterUserResponse, UseRegisterAccountParams>(
    "/api/neynar/auth/register-account",
    "POST",
    {
      onSuccess: (data, variables, context, meta) => {
        // Invalidate user-related queries to refresh data
        queryClient.invalidateQueries({
          queryKey: neynarQueryKeys.users.all(),
        });
        // Invalidate auth queries to refresh authentication state
        queryClient.invalidateQueries({
          queryKey: neynarQueryKeys.auth.all(),
        });
        // Call the user's onSuccess callback if provided
        if (options?.onSuccess) {
          options.onSuccess(data, variables, context, meta);
        }
      },
      ...options,
    },
  );
}

/**
 * Creates a new Farcaster account with onchain registration
 *
 * @param options - TanStack Query mutation options for callbacks and error handling
 * @returns TanStack Query mutation result
 *   - `mutate: (params:` {@link UseRegisterAccountOnchainParams}`) => void` - Trigger onchain registration
 *
 * @example
 * ```tsx
 * function RegisterOnchain() {
 *   const { mutate } = useRegisterAccountOnchain({
 *     onSuccess: (data) => console.log('TX:', data.transaction_hash)
 *   });
 *   return <button onClick={() => mutate({ registration, idem })}>Register</button>;
 * }
 * ```
 *
 * @see {@link useRegisterAccount} for standard offchain registration
 * @see {@link useRegisterDeveloperManagedSignedKey} for registering signers after account creation
 */
export function useRegisterAccountOnchain(
  options?: ExtendedMutationOptions<
    RegisterUserOnChainResponse,
    UseRegisterAccountOnchainParams
  >,
): MutationHookResult<
  RegisterUserOnChainResponse,
  UseRegisterAccountOnchainParams
> {
  const queryClient = useApiQueryClient();

  return useApiMutation<
    RegisterUserOnChainResponse,
    UseRegisterAccountOnchainParams
  >("/api/neynar/auth/register-account-onchain", "POST", {
    onSuccess: (data, variables, context, meta) => {
      // Invalidate user-related queries to refresh data
      queryClient.invalidateQueries({
        queryKey: neynarQueryKeys.users.all(),
      });
      // Invalidate auth queries to refresh authentication state
      queryClient.invalidateQueries({
        queryKey: neynarQueryKeys.auth.all(),
      });
      // Call the user's onSuccess callback if provided
      if (options?.onSuccess) {
        options.onSuccess(data, variables, context, meta);
      }
    },
    ...options,
  });
}

/**
 * Registers a signed key for developer-managed authentication
 *
 * @param options - TanStack Query mutation options for callbacks and error handling
 * @returns TanStack Query mutation result
 *   - `mutate: (params:` {@link UseRegisterDeveloperManagedSignedKeyParams}`) => void` - Trigger key registration
 *
 * @example
 * ```tsx
 * function RegisterKey() {
 *   const { mutate } = useRegisterDeveloperManagedSignedKey({
 *     onSuccess: (data) => console.log('Registered:', data.status)
 *   });
 *   const deadline = Math.floor(Date.now() / 1000) + 86400; // 24h recommended
 *   return <button onClick={() => mutate({ public_key, signature, app_fid, deadline })}>Register</button>;
 * }
 * ```
 *
 * @see {@link useDeveloperManagedAuth} for checking status of developer-managed signers
 * @see {@link useRegisterAccountOnchain} for registering accounts with signers in one transaction
 * @see {@link https://docs.neynar.com/reference/register-signed-key} for API reference
 */
export function useRegisterDeveloperManagedSignedKey(
  options?: ExtendedMutationOptions<
    RegisterSignedKeyForDeveloperManagedAuthAddress200Response,
    UseRegisterDeveloperManagedSignedKeyParams
  >,
): MutationHookResult<
  RegisterSignedKeyForDeveloperManagedAuthAddress200Response,
  UseRegisterDeveloperManagedSignedKeyParams
> {
  const queryClient = useApiQueryClient();

  return useApiMutation<
    RegisterSignedKeyForDeveloperManagedAuthAddress200Response,
    UseRegisterDeveloperManagedSignedKeyParams
  >("/api/neynar/auth/developer-managed/register-signed-key", "POST", {
    onSuccess: (data, variables, context, meta) => {
      // Invalidate auth-related queries to refresh authentication state
      queryClient.invalidateQueries({
        queryKey: neynarQueryKeys.auth.all(),
      });
      // Invalidate signer queries since we just registered a new key
      queryClient.invalidateQueries({
        queryKey: neynarQueryKeys.signers.all(),
      });
      if (options?.onSuccess) {
        options.onSuccess(data, variables, context, meta);
      }
    },
    ...options,
  });
}
