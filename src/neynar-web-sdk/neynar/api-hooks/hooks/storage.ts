/**
 * Neynar Storage API Hooks
 *
 * React Query hooks for Neynar storage-related operations.
 * Handles storage allocations, usage tracking, and storage purchasing.
 * Uses TanStack Query v5 with proper error handling and type safety.
 */
 
import {
  useApiQuery,
  useApiMutation,
  useApiQueryClient,
  STALE_TIME,
  type ExtendedMutationOptions,
  type MutationHookResult,
  type QueryHookOptions,
  type QueryHookResult,
} from "../../../private/api-hooks";
import { neynarQueryKeys } from "../query-keys";
import { buildNeynarQuery } from "../helpers";
import type {
  StorageAllocationsResponse,
  StorageUsageResponse,
} from "../sdk-response-types";
 
// ============================================================================
// Storage Mutation Hooks
// ============================================================================
 
/**
 * Parameters for purchasing storage units
 *
 * @see {@link useBuyStorage}
 */
type UseBuyStorageParams = {
  /**
   * The unique identifier of a farcaster user or app (unsigned integer)
   *
   * The Farcaster ID of the user purchasing storage
   */
  fid: number;
 
  /**
   * Number of storage units to buy
   *
   * A storage unit lets you store 5000 casts, 2500 reactions and 2500 links
   */
  units?: number;
 
  /**
   * An Idempotency key is a unique identifier for the request
   *
   * **Note:**
   * 1. This is used to prevent duplicate requests. Use the same idem key on retry attempts
   * 2. This should be a unique identifier for each request
   * 3. Recommended format is a 16-character string generated by the developer at the time of making this request
   */
  idem?: string;
};
 
/**
 * Rent storage units for a user for one year
 *
 * **Special Behaviors:**
 * - Storage is rented for one year from purchase date
 * - Idempotency: Use the `idem` parameter with the same value on retry attempts to prevent duplicate purchases
 * - Returns updated storage allocations after successful purchase
 *
 * @param options - TanStack Query mutation options for callbacks and error handling
 * @returns TanStack Query mutation result
 *   - `mutate: (params: UseBuyStorageParams) => void` - Trigger storage purchase
 *
 * @example Basic storage purchase
 * ```tsx
 * function BuyStorageButton({ fid }: { fid: number }) {
 *   const buyStorage = useBuyStorage({
 *     onSuccess: (data) => {
 *       console.log('New total units:', data.total_active_units);
 *     },
 *   });
 *
 *   const handleBuy = () => {
 *     buyStorage.mutate({
 *       fid,
 *       units: 1,
 *       idem: crypto.randomUUID(), // Recommended: 16-char unique string
 *     });
 *   };
 *
 *   return (
 *     <button onClick={handleBuy} disabled={buyStorage.isPending}>
 *       {buyStorage.isPending ? 'Purchasing...' : 'Buy Storage Unit'}
 *     </button>
 *   );
 * }
 * ```
 *
 * @see {@link useStorageAllocations} for viewing purchased storage allocations
 * @see {@link useStorageUsage} for checking current storage consumption
 */
export function useBuyStorage(
  options?: ExtendedMutationOptions<
    StorageAllocationsResponse,
    UseBuyStorageParams
  >,
): MutationHookResult<StorageAllocationsResponse, UseBuyStorageParams> {
  const queryClient = useApiQueryClient();
 
  return useApiMutation<StorageAllocationsResponse, UseBuyStorageParams>(
    "/api/neynar/storage/buy",
    "POST",
    {
      onSuccess: (data, variables) => {
        // Invalidate storage-related queries for the specific fid to refresh data
        queryClient.invalidateQueries({
          queryKey: neynarQueryKeys.storage.allocations(variables.fid),
        });
        queryClient.invalidateQueries({
          queryKey: neynarQueryKeys.storage.usage(variables.fid),
        });
        // Also invalidate all storage queries to ensure consistency
        queryClient.invalidateQueries({
          queryKey: neynarQueryKeys.storage.all(),
        });
      },
      ...options,
    },
  );
}
 
// ============================================================================
// Storage Query Hooks
// ============================================================================
 
/**
 * Parameters for fetching storage allocations
 *
 * @see {@link useStorageAllocations}
 */
type UseStorageAllocationsParams = {
  /**
   * The unique identifier of a farcaster user or app (unsigned integer)
   *
   * The FID of the user whose storage allocations to fetch
   */
  fid: number;
};
 
/**
 * Fetches storage allocations for a given user
 *
 * Shows how much storage capacity a user has purchased and when it expires.
 * Each storage unit provides capacity for 5000 casts, 2500 reactions, and 2500 links.
 *
 * @param params - Query parameters
 * @param options - TanStack Query options for caching and request behavior
 * @returns TanStack Query result with storage allocation data
 *
 * @example
 * ```tsx
 * function StorageAllocationDisplay({ fid }: { fid: number }) {
 *   const { data, isLoading } = useStorageAllocations({ fid });
 *   if (isLoading) return <div>Loading...</div>;
 *   return <div>Active Units: {data?.total_active_units || 0}</div>;
 * }
 * ```
 *
 * @see {@link useStorageUsage} for checking current storage consumption
 * @see {@link useBuyStorage} for purchasing additional storage capacity
 */
export function useStorageAllocations(
  params: UseStorageAllocationsParams,
  options?: QueryHookOptions<
    StorageAllocationsResponse,
    StorageAllocationsResponse
  >,
): QueryHookResult<StorageAllocationsResponse> {
  const queryParams = buildNeynarQuery({ ...params });
 
  return useApiQuery<StorageAllocationsResponse, StorageAllocationsResponse>(
    neynarQueryKeys.storage.allocations(params.fid),
    `/api/neynar/storage/allocations?${queryParams}`,
    {
      staleTime: STALE_TIME.FREQUENT, // 5 minutes - storage allocations change infrequently
      enabled: !!params.fid && params.fid > 0,
      ...options,
      select: (response: StorageAllocationsResponse) => {
        // SDK returns: { total_active_units?: number, allocations?: StorageAllocation[] }
        // Pass through the entire response - it's already the right structure
        return response;
      },
    },
  );
}
 
/**
 * Parameters for fetching storage usage
 *
 * @see {@link useStorageUsage}
 */
type UseStorageUsageParams = {
  /**
   * The unique identifier of a farcaster user or app (unsigned integer)
   *
   * The FID of the user whose storage usage to fetch
   */
  fid: number;
};
 
/**
 * Fetches storage usage for a given user
 *
 * Shows how much of the user's allocated storage capacity is currently being used
 * across casts, reactions, links, and other Farcaster actions. Use this to determine
 * when a user is approaching their storage limits and may need to purchase more.
 *
 * @param params - Query parameters
 * @param options - TanStack Query options for caching and request behavior
 * @returns TanStack Query result with storage usage data
 *
 * @example
 * ```tsx
 * function StorageUsageDisplay({ fid }: { fid: number }) {
 *   const { data, isLoading } = useStorageUsage({ fid });
 *   if (isLoading) return <div>Loading...</div>;
 *   return <div>Casts: {data?.casts?.used || 0} / {data?.casts?.capacity || 0}</div>;
 * }
 * ```
 *
 * @see {@link useStorageAllocations} for viewing total purchased storage capacity
 * @see {@link useBuyStorage} for purchasing additional storage when nearing limits
 */
export function useStorageUsage(
  params: UseStorageUsageParams,
  options?: QueryHookOptions<StorageUsageResponse, StorageUsageResponse>,
): QueryHookResult<StorageUsageResponse> {
  const queryParams = buildNeynarQuery({ ...params });
 
  return useApiQuery<StorageUsageResponse, StorageUsageResponse>(
    neynarQueryKeys.storage.usage(params.fid),
    `/api/neynar/storage/usage?${queryParams}`,
    {
      staleTime: STALE_TIME.FREQUENT, // 2 minutes - usage data changes more frequently than allocations
      enabled: !!params.fid && params.fid > 0,
      ...options,
      select: (response: StorageUsageResponse) => {
        // SDK returns: { object?, user?, casts?, reactions?, links?, verified_addresses?, username_proofs?, signers?, total_active_units? }
        // Pass through the entire response - it's already the right structure
        return response;
      },
    },
  );
}
 
// ============================================================================
// Utility Hooks
// ============================================================================
 
/**
 * Parameters for fetching combined storage status
 *
 * @see {@link useStorageStatus}
 */
type UseStorageStatusParams = {
  /**
   * The unique identifier of a farcaster user or app (unsigned integer)
   *
   * The FID of the user whose storage status to fetch
   */
  fid: number;
};
 
/**
 * Combined storage status hook
 *
 * Provides a convenient way to get both storage allocations and usage data in a single hook.
 * Executes both queries in parallel for optimal performance. This is useful for dashboard
 * views where you need to show both capacity and current usage together.
 *
 * @param params - Query parameters
 * @param options - TanStack Query options applied to both queries
 * @returns Object containing both allocation and usage query results
 *   - `allocations` - Result from {@link useStorageAllocations}
 *   - `usage` - Result from {@link useStorageUsage}
 *   - `isLoading: boolean` - True if either query is loading
 *   - `hasError: boolean` - True if either query has an error
 *   - `refetchAll: () => void` - Function to refetch both queries
 *
 * @example
 * ```tsx
 * function StorageOverview({ fid }: { fid: number }) {
 *   const { allocations, usage, isLoading } = useStorageStatus({ fid });
 *   if (isLoading) return <div>Loading...</div>;
 *   return (
 *     <div>
 *       <p>Units: {allocations.data?.total_active_units || 0}</p>
 *       <p>Casts: {usage.data?.casts?.used || 0} / {usage.data?.casts?.capacity || 0}</p>
 *     </div>
 *   );
 * }
 * ```
 *
 * @see {@link useStorageAllocations} for fetching only allocation data
 * @see {@link useStorageUsage} for fetching only usage data
 * @see {@link useBuyStorage} for purchasing additional storage
 */
export function useStorageStatus(
  params: UseStorageStatusParams,
  options?: QueryHookOptions<
    StorageAllocationsResponse | StorageUsageResponse,
    StorageAllocationsResponse | StorageUsageResponse
  >,
) {
  const allocations = useStorageAllocations(
    params,
    options as QueryHookOptions<
      StorageAllocationsResponse,
      StorageAllocationsResponse
    >,
  );
  const usage = useStorageUsage(
    params,
    options as QueryHookOptions<StorageUsageResponse, StorageUsageResponse>,
  );
 
  return {
    allocations,
    usage,
    isLoading: allocations.isLoading || usage.isLoading,
    hasError: allocations.error || usage.error,
    refetchAll: () => {
      allocations.refetch();
      usage.refetch();
    },
  };
}
 